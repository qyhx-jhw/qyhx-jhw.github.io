<!doctype html>
<html lang="zh-CN">
  <head>
    <title>Python：十种排序算法 // jhw 博客网站</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.73.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="蒋浩文" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://qyhx-jhw.github.io/css/main.min.366e0ee61030653c4f8925f9bd4a9db5b3c23b09a6fddf2bccb02e2426ecde43.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python：十种排序算法"/>
<meta name="twitter:description" content="以下内容来自于：  作者：牛奶芝麻 链接：https://www.jianshu.com/p/bbbab7fa77a2 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。     1.冒泡排序（Bubble Sort） def bubbleSort(nums): for i in range(len(nums) - 1): # 遍历 len(nums)-1 次 for j in range(len(nums) - i - 1): # 已排好序的部分不用再次遍历 if nums[j] &gt; nums[j&#43;1]: nums[j], nums[j&#43;1] = nums[j&#43;1], nums[j] # Python 交换两个数不用中间变量 return nums 2.选择排序（Selection Sort） 选择排序不受输入数据的影响，即在任何情况下时间复杂度不变。选择排序每次选出最小的元素，因此需要遍历 n-1 次。
def selectionSort(nums): for i in range(len(nums) - 1): # 遍历 len(nums)-1 次 minIndex = i for j in range(i &#43; 1, len(nums)): if nums[j] &lt; nums[minIndex]: # 更新最小值索引 minIndex = j nums[i], nums[minIndex] = nums[minIndex], nums[i] # 把最小数交换到前面 return nums 3."/>

    <meta property="og:title" content="Python：十种排序算法" />
<meta property="og:description" content="以下内容来自于：  作者：牛奶芝麻 链接：https://www.jianshu.com/p/bbbab7fa77a2 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。     1.冒泡排序（Bubble Sort） def bubbleSort(nums): for i in range(len(nums) - 1): # 遍历 len(nums)-1 次 for j in range(len(nums) - i - 1): # 已排好序的部分不用再次遍历 if nums[j] &gt; nums[j&#43;1]: nums[j], nums[j&#43;1] = nums[j&#43;1], nums[j] # Python 交换两个数不用中间变量 return nums 2.选择排序（Selection Sort） 选择排序不受输入数据的影响，即在任何情况下时间复杂度不变。选择排序每次选出最小的元素，因此需要遍历 n-1 次。
def selectionSort(nums): for i in range(len(nums) - 1): # 遍历 len(nums)-1 次 minIndex = i for j in range(i &#43; 1, len(nums)): if nums[j] &lt; nums[minIndex]: # 更新最小值索引 minIndex = j nums[i], nums[minIndex] = nums[minIndex], nums[i] # 把最小数交换到前面 return nums 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://qyhx-jhw.github.io/post/python_sort/" />
<meta property="article:published_time" content="2020-06-29T17:05:32+08:00" />
<meta property="article:modified_time" content="2020-06-29T17:05:32+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://qyhx-jhw.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="蒋浩文" /></a>
      <h1>jhw 博客网站</h1>
      <p>好好学习，天天向上。</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/qyhx-jhw/" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="/post/about" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-home">
  <title>home</title>
  <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Python：十种排序算法</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          
          2020-06-29
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          阅读4 分钟
        </div></div>
    </header>
    <div class="post-content">
      <ul>
<li>以下内容来自于：
<ul>
<li>作者：牛奶芝麻</li>
<li>链接：<a href="https://www.jianshu.com/p/bbbab7fa77a2">https://www.jianshu.com/p/bbbab7fa77a2</a></li>
<li>来源：简书</li>
<li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="1冒泡排序bubble-sort">1.冒泡排序（Bubble Sort）</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bubbleSort</span>(nums):
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>): <span style="color:#75715e"># 遍历 len(nums)-1 次</span>
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(nums) <span style="color:#f92672">-</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>): <span style="color:#75715e"># 已排好序的部分不用再次遍历</span>
            <span style="color:#66d9ef">if</span> nums[j] <span style="color:#f92672">&gt;</span> nums[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]:
                nums[j], nums[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> nums[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], nums[j] <span style="color:#75715e"># Python 交换两个数不用中间变量</span>
    <span style="color:#66d9ef">return</span> nums
</code></pre></div><h1 id="2选择排序selection-sort">2.选择排序（Selection Sort）</h1>
<p>选择排序不受输入数据的影响，即在任何情况下时间复杂度不变。选择排序每次选出最小的元素，因此需要遍历 n-1 次。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">selectionSort</span>(nums):
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>):  <span style="color:#75715e"># 遍历 len(nums)-1 次</span>
        minIndex <span style="color:#f92672">=</span> i
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, len(nums)):
            <span style="color:#66d9ef">if</span> nums[j] <span style="color:#f92672">&lt;</span> nums[minIndex]:  <span style="color:#75715e"># 更新最小值索引</span>
                minIndex <span style="color:#f92672">=</span> j  
        nums[i], nums[minIndex] <span style="color:#f92672">=</span> nums[minIndex], nums[i] <span style="color:#75715e"># 把最小数交换到前面</span>
    <span style="color:#66d9ef">return</span> nums
</code></pre></div><h1 id="3插入排序insertion-sort">3.插入排序（Insertion Sort）</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insertionSort</span>(nums):
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>):  <span style="color:#75715e"># 遍历 len(nums)-1 次</span>
        curNum, preIndex <span style="color:#f92672">=</span> nums[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], i  <span style="color:#75715e"># curNum 保存当前待插入的数</span>
        <span style="color:#66d9ef">while</span> preIndex <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> curNum <span style="color:#f92672">&lt;</span> nums[preIndex]: <span style="color:#75715e"># 将比 curNum 大的元素向后移动</span>
            nums[preIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> nums[preIndex]
            preIndex <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
        nums[preIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> curNum  <span style="color:#75715e"># 待插入的数的正确位置   </span>
    <span style="color:#66d9ef">return</span> nums
</code></pre></div><h1 id="4希尔排序shell-sort">4.希尔排序（Shell Sort）</h1>
<p>希尔排序是插入排序的一种更高效率的实现。它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p>
<p>【例子】对于待排序列 {44，12，59，36，62，43，94，7，35，52，85}，我们可设定增量序列为 {5，3，1}。</p>
<p>【解析】第一个增量为 5，因此 {44，43，85}、{12，94}、{59，7}、{36，35}、{62，52} 分别隶属于同一个子序列，子序列内部进行插入排序；然后选取第二个增量3，因此 {43，35，94，62}、{12，52，59，85}、{7，44，36} 分别隶属于同一个子序列；最后一个增量为 1，这一次排序相当于简单插入排序，但是经过前两次排序，序列已经基本有序，因此此次排序时间效率就提高了很多。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">shellSort</span>(nums):
    lens <span style="color:#f92672">=</span> len(nums)
    gap <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>  
    <span style="color:#66d9ef">while</span> gap <span style="color:#f92672">&lt;</span> lens <span style="color:#f92672">//</span> <span style="color:#ae81ff">3</span>:
        gap <span style="color:#f92672">=</span> gap <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>  <span style="color:#75715e"># 动态定义间隔序列</span>
    <span style="color:#66d9ef">while</span> gap <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(gap, lens):
            curNum, preIndex <span style="color:#f92672">=</span> nums[i], i <span style="color:#f92672">-</span> gap  <span style="color:#75715e"># curNum 保存当前待插入的数</span>
            <span style="color:#66d9ef">while</span> preIndex <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> curNum <span style="color:#f92672">&lt;</span> nums[preIndex]:
                nums[preIndex <span style="color:#f92672">+</span> gap] <span style="color:#f92672">=</span> nums[preIndex] <span style="color:#75715e"># 将比 curNum 大的元素向后移动</span>
                preIndex <span style="color:#f92672">-=</span> gap
            nums[preIndex <span style="color:#f92672">+</span> gap] <span style="color:#f92672">=</span> curNum  <span style="color:#75715e"># 待插入的数的正确位置</span>
        gap <span style="color:#f92672">//=</span> <span style="color:#ae81ff">3</span>  <span style="color:#75715e"># 下一个动态间隔</span>
    <span style="color:#66d9ef">return</span> nums
</code></pre></div><h1 id="5归并排序merge-sort">5.归并排序（Merge Sort）</h1>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ol>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法）</li>
<li>自下而上的迭代
和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">mergeSort</span>(nums):
    <span style="color:#75715e"># 归并过程</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">merge</span>(left, right):
        result <span style="color:#f92672">=</span> []  <span style="color:#75715e"># 保存归并后的结果</span>
        i <span style="color:#f92672">=</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> len(left) <span style="color:#f92672">and</span> j <span style="color:#f92672">&lt;</span> len(right):
            <span style="color:#66d9ef">if</span> left[i] <span style="color:#f92672">&lt;=</span> right[j]:
                result<span style="color:#f92672">.</span>append(left[i])
                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                result<span style="color:#f92672">.</span>append(right[j])
                j <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        result <span style="color:#f92672">=</span> result <span style="color:#f92672">+</span> left[i:] <span style="color:#f92672">+</span> right[j:] <span style="color:#75715e"># 剩余的元素直接添加到末尾</span>
        <span style="color:#66d9ef">return</span> result
    <span style="color:#75715e"># 递归过程</span>
    <span style="color:#66d9ef">if</span> len(nums) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>:
        <span style="color:#66d9ef">return</span> nums
    mid <span style="color:#f92672">=</span> len(nums) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
    left <span style="color:#f92672">=</span> mergeSort(nums[:mid])
    right <span style="color:#f92672">=</span> mergeSort(nums[mid:])
    <span style="color:#66d9ef">return</span> merge(left, right)
</code></pre></div><h1 id="6快速排序quick-sort">6.快速排序（Quick Sort）</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">quickSort</span>(nums):  <span style="color:#75715e"># 这种写法的平均空间复杂度为 O(nlogn)</span>
    <span style="color:#66d9ef">if</span> len(nums) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>:
        <span style="color:#66d9ef">return</span> nums
    pivot <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>]  <span style="color:#75715e"># 基准值</span>
    left <span style="color:#f92672">=</span> [nums[i] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(nums)) <span style="color:#66d9ef">if</span> nums[i] <span style="color:#f92672">&lt;</span> pivot] 
    right <span style="color:#f92672">=</span> [nums[i] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(nums)) <span style="color:#66d9ef">if</span> nums[i] <span style="color:#f92672">&gt;=</span> pivot]
    <span style="color:#66d9ef">return</span> quickSort(left) <span style="color:#f92672">+</span> [pivot] <span style="color:#f92672">+</span> quickSort(right)

<span style="color:#e6db74">&#39;&#39;&#39;
</span><span style="color:#e6db74">@param nums: 待排序数组
</span><span style="color:#e6db74">@param left: 数组上界
</span><span style="color:#e6db74">@param right: 数组下界
</span><span style="color:#e6db74">&#39;&#39;&#39;</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">quickSort2</span>(nums, left, right):  <span style="color:#75715e"># 这种写法的平均空间复杂度为 O(logn) </span>
    <span style="color:#75715e"># 分区操作</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">partition</span>(nums, left, right):
        pivot <span style="color:#f92672">=</span> nums[left]  <span style="color:#75715e"># 基准值</span>
        <span style="color:#66d9ef">while</span> left <span style="color:#f92672">&lt;</span> right:
            <span style="color:#66d9ef">while</span> left <span style="color:#f92672">&lt;</span> right <span style="color:#f92672">and</span> nums[right] <span style="color:#f92672">&gt;=</span> pivot:
                right <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
            nums[left] <span style="color:#f92672">=</span> nums[right]  <span style="color:#75715e"># 比基准小的交换到前面</span>
            <span style="color:#66d9ef">while</span> left <span style="color:#f92672">&lt;</span> right <span style="color:#f92672">and</span> nums[left] <span style="color:#f92672">&lt;=</span> pivot:
                left <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            nums[right] <span style="color:#f92672">=</span> nums[left]  <span style="color:#75715e"># 比基准大交换到后面</span>
        nums[left] <span style="color:#f92672">=</span> pivot <span style="color:#75715e"># 基准值的正确位置，也可以为 nums[right] = pivot</span>
        <span style="color:#66d9ef">return</span> left  <span style="color:#75715e"># 返回基准值的索引，也可以为 return right</span>
    <span style="color:#75715e"># 递归操作</span>
    <span style="color:#66d9ef">if</span> left <span style="color:#f92672">&lt;</span> right:
        pivotIndex <span style="color:#f92672">=</span> partition(nums, left, right)
        quickSort2(nums, left, pivotIndex <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)  <span style="color:#75715e"># 左序列</span>
        quickSort2(nums, pivotIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, right) <span style="color:#75715e"># 右序列</span>
    <span style="color:#66d9ef">return</span> nums
</code></pre></div><h1 id="7堆排序heap-sort">7.堆排序（Heap Sort）</h1>
<ul>
<li>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ol>
<li>大根堆：每个节点的值都大于或等于其子节点的值，用于升序排列；</li>
<li>小根堆：每个节点的值都小于或等于其子节点的值，用于降序排列。</li>
</ol>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 大根堆（从小打大排列）</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">heapSort</span>(nums):
    <span style="color:#75715e"># 调整堆</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">adjustHeap</span>(nums, i, size):
        <span style="color:#75715e"># 非叶子结点的左右两个孩子</span>
        lchild <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        rchild <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>
        <span style="color:#75715e"># 在当前结点、左孩子、右孩子中找到最大元素的索引</span>
        largest <span style="color:#f92672">=</span> i 
        <span style="color:#66d9ef">if</span> lchild <span style="color:#f92672">&lt;</span> size <span style="color:#f92672">and</span> nums[lchild] <span style="color:#f92672">&gt;</span> nums[largest]: 
            largest <span style="color:#f92672">=</span> lchild 
        <span style="color:#66d9ef">if</span> rchild <span style="color:#f92672">&lt;</span> size <span style="color:#f92672">and</span> nums[rchild] <span style="color:#f92672">&gt;</span> nums[largest]: 
            largest <span style="color:#f92672">=</span> rchild 
        <span style="color:#75715e"># 如果最大元素的索引不是当前结点，把大的结点交换到上面，继续调整堆</span>
        <span style="color:#66d9ef">if</span> largest <span style="color:#f92672">!=</span> i: 
            nums[largest], nums[i] <span style="color:#f92672">=</span> nums[i], nums[largest] 
            <span style="color:#75715e"># 第 2 个参数传入 largest 的索引是交换前大数字对应的索引</span>
            <span style="color:#75715e"># 交换后该索引对应的是小数字，应该把该小数字向下调整</span>
            adjustHeap(nums, largest, size)
    <span style="color:#75715e"># 建立堆</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">builtHeap</span>(nums, size):
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums)<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>)[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]: <span style="color:#75715e"># 从倒数第一个非叶子结点开始建立大根堆</span>
            adjustHeap(nums, i, size) <span style="color:#75715e"># 对所有非叶子结点进行堆的调整</span>
        <span style="color:#75715e"># print(nums)  # 第一次建立好的大根堆</span>
    <span style="color:#75715e"># 堆排序 </span>
    size <span style="color:#f92672">=</span> len(nums)
    builtHeap(nums, size) 
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums))[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]: 
        <span style="color:#75715e"># 每次根结点都是最大的数，最大数放到后面</span>
        nums[<span style="color:#ae81ff">0</span>], nums[i] <span style="color:#f92672">=</span> nums[i], nums[<span style="color:#ae81ff">0</span>] 
        <span style="color:#75715e"># 交换完后还需要继续调整堆，只需调整根节点，此时数组的 size 不包括已经排序好的数</span>
        adjustHeap(nums, <span style="color:#ae81ff">0</span>, i) 
    <span style="color:#66d9ef">return</span> nums  <span style="color:#75715e"># 由于每次大的都会放到后面，因此最后的 nums 是从小到大排列</span>
</code></pre></div><h1 id="8计数排序counting-sort">8.计数排序（Counting Sort）</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countingSort</span>(nums):
    bucket <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (max(nums) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e"># 桶的个数</span>
    <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> nums:  <span style="color:#75715e"># 将元素值作为键值存储在桶中，记录其出现的次数</span>
        bucket[num] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>  <span style="color:#75715e"># nums 的索引</span>
    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(bucket)):
        <span style="color:#66d9ef">while</span> bucket[j] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
            nums[i] <span style="color:#f92672">=</span> j
            bucket[j] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
            i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">return</span> nums
</code></pre></div><h1 id="9桶排序bucket-sort">9.桶排序（Bucket Sort）</h1>
<p>为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bucketSort</span>(nums, defaultBucketSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>):
    maxVal, minVal <span style="color:#f92672">=</span> max(nums), min(nums)
    bucketSize <span style="color:#f92672">=</span> defaultBucketSize  <span style="color:#75715e"># 如果没有指定桶的大小，则默认为5</span>
    bucketCount <span style="color:#f92672">=</span> (maxVal <span style="color:#f92672">-</span> minVal) <span style="color:#f92672">//</span> bucketSize <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>  <span style="color:#75715e"># 数据分为 bucketCount 组</span>
    buckets <span style="color:#f92672">=</span> []  <span style="color:#75715e"># 二维桶</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(bucketCount):
        buckets<span style="color:#f92672">.</span>append([])
    <span style="color:#75715e"># 利用函数映射将各个数据放入对应的桶中</span>
    <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> nums:
        buckets[(num <span style="color:#f92672">-</span> minVal) <span style="color:#f92672">//</span> bucketSize]<span style="color:#f92672">.</span>append(num)
    nums<span style="color:#f92672">.</span>clear()  <span style="color:#75715e"># 清空 nums</span>
    <span style="color:#75715e"># 对每一个二维桶中的元素进行排序</span>
    <span style="color:#66d9ef">for</span> bucket <span style="color:#f92672">in</span> buckets:
        insertionSort(bucket)  <span style="color:#75715e"># 假设使用插入排序</span>
        nums<span style="color:#f92672">.</span>extend(bucket)    <span style="color:#75715e"># 将排序好的桶依次放入到 nums 中</span>
    <span style="color:#66d9ef">return</span> nums
</code></pre></div><h1 id="10基数排序radix-sort">10.基数排序（Radix Sort）</h1>
<p>基数排序有两种方法：</p>
<ol>
<li>MSD （主位优先法）：从高位开始进行排序</li>
<li>LSD （次位优先法）：从低位开始进行排序</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># LSD Radix Sort</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">radixSort</span>(nums):
    mod <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
    div <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    mostBit <span style="color:#f92672">=</span> len(str(max(nums)))  <span style="color:#75715e"># 最大数的位数决定了外循环多少次</span>
    buckets <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> range(mod)] <span style="color:#75715e"># 构造 mod 个空桶</span>
    <span style="color:#66d9ef">while</span> mostBit:
        <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> nums:  <span style="color:#75715e"># 将数据放入对应的桶中</span>
            buckets[num <span style="color:#f92672">//</span> div <span style="color:#f92672">%</span> mod]<span style="color:#f92672">.</span>append(num)
        i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>  <span style="color:#75715e"># nums 的索引</span>
        <span style="color:#66d9ef">for</span> bucket <span style="color:#f92672">in</span> buckets:  <span style="color:#75715e"># 将数据收集起来</span>
            <span style="color:#66d9ef">while</span> bucket:
                nums[i] <span style="color:#f92672">=</span> bucket<span style="color:#f92672">.</span>pop(<span style="color:#ae81ff">0</span>) <span style="color:#75715e"># 依次取出</span>
                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        div <span style="color:#f92672">*=</span> <span style="color:#ae81ff">10</span>
        mostBit <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">return</span> nums
</code></pre></div>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
